### Local-recipes: Developer Guidelines

These notes capture project-specific knowledge for building and testing recipes in this repo. They assume you are an experienced Conda/conda-forge developer on Windows; adapt paths accordingly for macOS/Linux.

#### Repo overview
- This is a conda-forge style local "staged-recipes" workspace. Each subfolder in `recipes/` is a recipe to build.
- Two recipe formats are supported, but do not mix them at the same time:
  - Legacy conda-build format: `meta.yaml`
  - Modern Rattler Build format: `recipe.yaml` (Prefix’s recipe-format)
- Build orchestration lives in `.ci_support/build_all.py` and the platform-specific scripts in `.scripts/`.
- Global pinning and variants come from root `conda_build_config.yaml` and platform variant files in `.ci_support/*.yaml`.

#### Toolchain and environment
- The bootstrap environment is declared in `environment.yaml` and includes:
  - `conda`, `conda-libmamba-solver`, `conda-build`, `conda-index`
  - `conda-forge-ci-setup`, `conda-forge-pinning`
  - `networkx` (build graph), and `rattler-build-conda-compat`
- The Windows runner script will install this environment automatically using micromamba if needed.

#### Fast start on Windows (recommended)
- Preferred entry point: `.scripts\run_win_build.bat`
  - What it does:
    - Provisions Miniforge into `%MINIFORGE_HOME%` (or `%USERPROFILE%\Miniforge3` by default) using micromamba.
    - Activates it, sets strict channel priority and libmamba solver.
    - Sets up conda-forge build configuration via `run_conda_forge_build_setup`.
    - Removes any recipes present in the `main` branch to ensure you only build changed/new local recipes.
    - Builds all recipes found in `recipes/` by invoking `.ci_support/build_all.py`.
    - Indexes `%CONDA_BLD_PATH%` for local artifact resolution.
  - Usage:
    - Open "Developer Command Prompt for VS" or a PowerShell with script execution allowed.
    - From repo root:
      - `SET CONFIG=win64` (optional; defaults based on host platform)
      - `CALL .scripts\run_win_build.bat`

#### Cross-platform local builds
- Cross-platform dispatcher: `build-locally.py`
  - Chooses the correct backend based on host OS and `CONFIG`/`--filter`.
  - On Windows it delegates to `.scripts\run_win_build.bat`.
  - On Linux/macOS it uses the analogous `.scripts/run_docker_build.sh` or `.scripts/run_osx_build.sh` generated by conda-smithy.
  - Typical usage from repo root:
    - `python build-locally.py win64`
    - `python build-locally.py --filter win*` then select interactively.

#### Building a single recipe (targeted)
- For recipes with `recipe.yaml` (Rattler Build):
  - You can invoke Rattler Build directly for a single recipe to iterate faster.
  - Ensure the tool is installed in an environment with the pins/variants you intend to use. If you used the Windows script above, you already have compatibility shims; otherwise:
    - `conda create -n rb -c conda-forge python=3.12 rattler-build-conda-compat conda-forge-pinning conda conda-build conda-libmamba-solver -y`
    - `conda activate rb`
  - Example (Windows):
    - `rattler-build build recipes\py-key-value --target-platform win-64 -c conda-forge`
  - Notes:
    - Channel `local` is auto-added by Rattler Build; `-c conda-forge` ensures access to CF dependencies.
    - To align with CI variants, pass a variant config: `--variant-config .ci_support\win64.yaml`.
- For legacy `meta.yaml` recipes:
  - Use conda-build: `conda-build recipes\<recipe>`
  - Or from this repo’s tooling, let `.ci_support/build_all.py` compute order and build dependencies.

#### How recipe tests work here
- Tests are defined inside the recipe itself and run during the build step:
  - Rattler Build (`recipe.yaml`): under `recipe: tests:` with entries like `python: imports: [...]`, `script: [...]`, etc.
  - Conda-build (`meta.yaml`): under `test:` with `imports`, `commands`, `requires`, etc.
- Example from `recipes/py-key-value/recipe.yaml`:
  - `outputs[0].tests[0].python.imports:` checks importability of `key_value` modules and enforces `pip_check: true`.
  - Additional `script` checks verify the installed distribution version and run `pip check`.
- Implication: If a build succeeds in this repo, the recipe’s functional smoke tests have already executed.

#### Running just the tests
- Conda-build supports testing an existing artifact: `conda-build --test <path-to-tar.bz2 or .conda>`
- With Rattler Build, tests are integrated into `rattler-build build`. If you have an existing artifact, you can test with the equivalent Rattler command where available, but the common workflow is to re-run the build for that recipe.

#### Adding tests to a recipe.yaml (Rattler Build)
- Minimal patterns that work well here:
  - Import checks:
    ```yaml
    tests:
      - python:
          imports:
            - your_top_level_pkg
          pip_check: true
          python_version:
            - ${{ python_min }}.*
            - ${{ python_check_max }}.*
    ```
  - Runtime command checks and version assertions:
    ```yaml
    - requirements:
        run:
          - python ${{ python_min }}.*
          - pip
      script:
        - python -c "from importlib.metadata import version; assert version('your-dist') == '${{ version }}'"
        - pip check
    ```
- Prefer simple, deterministic tests that don’t hit the network and don’t require large optional extras. If you must exercise optional extras, declare them as `run_constraints` to avoid over-constraining the DAG.

#### Verified simple test example for contributors
- For a super-fast sanity check (no downloads, no build), you can locally validate the structure of a known recipe file. We used the following Python snippet during preparation and confirmed it passes on this repo:
  ```python
  from pathlib import Path
  recipe = Path(r"recipes/py-key-value/recipe.yaml")
  text = recipe.read_text(encoding="utf-8")
  required = ["schema_version:", "build:", "outputs:", "tests:"]
  missing = [m for m in required if m not in text]
  assert not missing, f"Missing markers: {missing}"
  print("Sanity test passed")
  ```
  - Run from repo root: `python - <<"PY"` then paste the snippet, or save as a temp file and execute with `python temp_test_recipe_yaml.py`.
  - Rationale: this provides a zero-network smoke check before invoking the heavier build pipeline.

#### CI and build graph notes
- `.ci_support/build_all.py` determines whether to use conda-build or Rattler Build based on presence of `meta.yaml` vs `recipe.yaml` among the recipes (mixing both in one run is rejected).
- It constructs a dependency graph using `conda.resolve`/`networkx` and enforces a topological build order for `meta.yaml` cases; for `recipe.yaml` it shells out to `rattler-build build` with combined variant configuration derived from `conda_build_config.yaml` and `.ci_support/<platform>.yaml`.
- CUDA/CentOS detection is built-in to alter defaults when needed.

#### Style and linting
- Python linting in this repo is minimal: `setup.cfg` configures flake8 with `max-line-length = 88`. Mirror nearby code style when editing helper scripts.
- YAML style: follow existing patterns in recipes; respect the Prefix `recipe-format` schema headers:
  - `# yaml-language-server: $schema=https://raw.githubusercontent.com/prefix-dev/recipe-format/main/schema.json`

#### Common pitfalls and tips
- Don’t mix `meta.yaml` and `recipe.yaml` recipes in the same build run.
- Keep `noarch: python` only for pure-Python packages that don’t need compiled artifacts and don’t perform OS-conditional logic at install time.
- When using `pin_subpackage(...)`, prefer `exact=True` when outputs are co-versioned in a multi-output recipe.
- Use `run_constraints` instead of hard `run` dependencies for optional extras to keep the solver flexible.
- Make sure `pip_check: true` is present in Python tests to catch metadata issues early.
- On Windows, if `.scripts\run_win_build.bat` fails before provisioning, check corporate proxy/SSL and ensure PowerShell’s execution policy allows the commands, or run from a classic `cmd.exe`.

#### Quick reference commands
- Build everything on Windows: `CALL .scripts\run_win_build.bat`
- Build everything (cross-platform dispatcher): `python build-locally.py win64`
- Build a single Rattler recipe: `rattler-build build recipes\<name> --target-platform win-64 -c conda-forge --variant-config .ci_support\win64.yaml`
- Build a single conda-build recipe: `conda-build recipes\<name>`
- Test an existing conda-build artifact: `conda-build --test <artifact>`

